const locals = require('../main/locals.js');
const {
	D_TEXT_ENCODER,
	D_TEXT_DECODER,
	AT_UTF_16_TOKEN,
	popcount_uint32,
} = locals;

const BufferEncoder = require('../class/buffer-encoder.js');
const BufferDecoder = require('../class/buffer-decoder.js');
const BitsequenceWriter = require('../class/bitsequence-writer.js');
const BitsequenceReader = require('../class/bitsequence-reader.js');

// creates the smallest uint typed array that satisfies the requisite `range`
function uint_array(n_range) {
	if(!Number.isInteger(n_range) && 'bigint' !== typeof n_range) {
		throw new TypeError(`uint size '${n_range}' is not an integer!`);
	}
	else if(n_range <= 0xff) {
		return Uint8Array;
	}
	else if(n_range <= 0xffff) {
		return Uint16Array;
	}
	else if(n_range <= 0xffffffff) {
		return Uint32Array;
	}
	else if(n_range <= 0xffffffffffffffffn) {
		return BigUint64Array;
	}
};


const F_READ_0 = () => 0;
const F_READ_1 = (at, ib) => at[ib];
const F_WRITE_0 = (at, ib) => {
	at[ib] = 0;
	return at;
};
const F_WRITE_1 = (at, ib, x) => {
	at[ib] = x & 0xff;
	return at;
};

@.{
	function* mk_fast(s_what, b_le, f_each, f_out) {
		// shared functions
		yield /* syntax: js */ `
			// 0 bytes
			F_${s_what.toUpperCase()}_0,

			// 1 byte
			F_${s_what.toUpperCase()}_1,
		`

		let sj_op_shift = 'read' === s_what? '<<': '>>>';
		let sj_op_mul = 'read' === s_what? '*': '/';

		// each byte width
		for(let nb=2; nb<8; nb++) {
			// build operations table
			let a_ops = [];
			let ib_start = b_le? 0: nb-1;
			let n_change = b_le? +1: -1;
			let ib_stop = b_le? nb: -1;
			for(let ib=ib_start, ns=0; ib!==ib_stop; ib+=n_change, ns+=8) {
				// access typed array element
				let sj_access = /* syntax: js */ `at[ib${ib? `+${ib}`: ''}]`;

				// bit shift value
				let sj_shift = '';
				if(ns > 24) {
					sj_shift = /* syntax: js.value */ `${sj_op_mul} 0x1${'0'.repeat(ns * 0.25)}`;
				}
				else if(ns) {
					sj_shift = /* syntax: js.value */ `${sj_op_shift} ${ns}`;
				}

				// byte component
				a_ops.push(f_each(sj_access, sj_shift, ns));
			}

			if(!b_le) a_ops.reverse();

			// OR components together
			yield /* syntax: js */ `
				// ${nb} bytes
				(at, ib${'read' === s_what? '': ', x'}) => ${f_out(a_ops)},
			`;
		}
	}

	function* mk_fast_reads(b_le) {
		yield* mk_fast('read', b_le, (sj_access, sj_shift, ns) => {
			return ns? /* syntax: js */ `(${sj_access} ${sj_shift})`: sj_access;
		}, a_ops => a_ops.join(' | '));
	}

	function* mk_fast_writes(b_le) {
		yield* mk_fast('write', b_le, (sj_access, sj_shift, ns) => {
			// byte component
			let sj_assign = ns? /* syntax: js */ `(x ${sj_shift})`: 'x';

			return /* syntax: js */ `${sj_access} = ${sj_assign} & 0xff;`;
		}, a_ops => /* syntax: js */ `{
			${a_ops.join('\n\t\t')}
			return at;
		}`);
	}
}


const H_FAST_READS_BE = [@*{
	yield* mk_fast_reads(false);
}];

const H_FAST_READS_LE = [@*{
	yield* mk_fast_reads(true);
}];

const H_FAST_WRITES_BE = [@*{
	yield* mk_fast_writes(false);
}];

const H_FAST_WRITES_LE = [@*{
	yield* mk_fast_writes(true);
}];


module.exports = Object.assign({
	fitUintArray: uint_array,
	newUintArray: (n_range, n_size) => new (uint_array(n_range))(n_size),

	encodeUtf8: s_chunk => D_TEXT_ENCODER.encode(s_chunk),
	encodeUtf16(s_chunk) {
		// encode chunk as utf-16le
		let ab_chunk = Buffer.from(s_chunk, 'utf-16le');

		// prefix buffer w/ utf-16 token
		return Buffer.concat([AT_UTF_16_TOKEN, ab_chunk], ab_chunk.length + 1);
	},

	decodeUtf8: at_chunk => D_TEXT_DECODER.decode(at_chunk),

	decodeVuint(at_contents, ib_read=0) {
		let gc_decode = {
			_at_contents: at_contents,
			_ib_read: ib_read,
		};

		let x_value = BufferDecoder.$_decode_vuint(gc_decode);

		return [x_value, gc_decode._ib_read];
	},

	decodeVbigint(at_contents, ib_read=0) {
		let gc_decode = {
			_at_contents: at_contents,
			_ib_read: ib_read,
		};

		let x_value = BufferDecoder.$_decode_vbigint(gc_decode);

		return [x_value, gc_decode._ib_read];
	},

	readUintLE(at_contents, ib_read, nb_read) {
		return H_FAST_READS_LE[nb_read](at_contents, ib_read);
	},

	readerUintLE(nb_read) {
		return H_FAST_READS_LE[nb_read];
	},

	writeUintLE(at_contents, ib_write, nb_write, x_value) {
		H_FAST_WRITES_LE[nb_write](at_contents, ib_write, x_value);
		return at_contents;
	},

	writerUintLE(nb_write) {
		return H_FAST_WRITES_LE[nb_write];
	},

	readUintBE(at_contents, ib_read, nb_read) {
		return H_FAST_READS_BE[nb_read](at_contents, ib_read);
	},

	readerUintBE(nb_read) {
		return H_FAST_READS_BE[nb_read];
	},

	writeUintBE(at_contents, ib_write, nb_write, x_value) {
		return H_FAST_WRITES_BE[nb_write](at_contents, ib_write, x_value);
	},

	writerUintBE(nb_write) {
		return H_FAST_WRITES_BE[nb_write];
	},

	concat2(at_a, at_b) {
		let nb_a = at_a.length;
		let at_out = new Uint8Array(nb_a+at_b.length);

		at_out.set(at_a);
		at_out.set(at_b, nb_a);

		return at_out;
	},

	concat(a_list, nb_list=a_list.reduce((c, at) => c+at.length, 0)) {
		let at_out = new Uint8Array(nb_list);

		let ib_write = 0;
		for(let at_item of a_list) {
			at_out.set(at_item, ib_write);
			ib_write += at_item.length;
		}

		return at_out;
	},

	BitsequenceWriter,
	BitsequenceReader,

	BufferEncoder,
	BufferDecoder,

	constants: locals,

	popcountUint32: popcount_uint32,
});
